// ============================================================================
// TAG FILTER MODAL - Visual tag filter builder with boolean logic
// ============================================================================

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { createPortal } from 'react-dom';

import { Search, X, ChevronDown } from 'lucide-react';
import { FocusTrap } from '../common/FocusTrap';
import { ErrorBoundary } from '../common/ErrorBoundary';
import type { Tag, TagFilterExpression } from '../../../shared/types/tag-types';
import { createLogger } from '../../../shared/logger';
import { toast } from '../../stores/toastStore';

const logger = createLogger('TagFilterModal');

// ============================================================================
// TYPES
// ============================================================================

export interface TagFilterModalProps {
  isOpen: boolean;
  onClose: () => void;
  onApply: (expression: TagFilterExpression | null) => void;
  initialExpression?: TagFilterExpression | null;
}

type FilterLogic = 'AND' | 'OR';

// ============================================================================
// FILTER GROUP TYPES
// ============================================================================

interface FilterCondition {
  id: string;
  tagId: number | null;
}

interface FilterGroup {
  id: string;
  conditions: FilterCondition[];
  internalLogic: FilterLogic;
  negated: boolean;
}

interface FilterState {
  groups: FilterGroup[];
  groupLogic: FilterLogic;
}

// ============================================================================
// COMPONENT
// ============================================================================

export function TagFilterModal({
  isOpen,
  onClose,
  onApply,
  initialExpression = null,
}: TagFilterModalProps) {
  // State
  const [searchQuery, setSearchQuery] = useState('');
  const [filterState, setFilterState] = useState<FilterState>({
    groups: [{
      id: crypto.randomUUID(),
      conditions: [{ id: crypto.randomUUID(), tagId: null }],
      internalLogic: 'AND',
      negated: false,
    }],
    groupLogic: 'AND',
  });
  const [allTags, setAllTags] = useState<Tag[]>([]);

  // Refs
  const searchInputRef = useRef<HTMLInputElement>(null);

  // ============================================================================
  // LOAD TAGS
  // ============================================================================

  const loadTags = useCallback(async () => {
    try {
      const allTagsResult = await window.goodvibes.getAllTags();

      if (allTagsResult.success) {
        const sorted = [...allTagsResult.data].sort((a, b) => (b.usageCount ?? 0) - (a.usageCount ?? 0));
        setAllTags(sorted);
      } else {
        logger.error("Failed to load tags", { error: allTagsResult.error });
        toast.error("Failed to load tags");
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      logger.error("Failed to load tag data", { error: errorMessage });
      toast.error("Failed to load tags");
    }
  }, []);

  useEffect(() => {
    if (isOpen) {
      void loadTags();
    }
  }, [isOpen, loadTags]);

  // ============================================================================
  // INITIALIZE FROM EXPRESSION
  // ============================================================================

  useEffect(() => {
    if (isOpen && initialExpression) {
      // Parse initial expression to FilterState
      const parsed = parseExpressionToGroups(initialExpression);
      setFilterState(parsed);
    } else if (isOpen) {
      // Reset state when opening fresh
      setFilterState({
        groups: [{
          id: crypto.randomUUID(),
          conditions: [{ id: crypto.randomUUID(), tagId: null }],
          internalLogic: 'AND',
          negated: false,
        }],
        groupLogic: 'AND',
      });
      setSearchQuery('');
    }
  }, [isOpen, initialExpression]);

  // ============================================================================
  // APPLY/CANCEL HANDLERS
  // ============================================================================

  const handleApply = useCallback(() => {
    // Check if any valid tags are selected
    const hasValidTags = filterState.groups.some(group =>
      group.conditions.some(c => c.tagId !== null)
    );

    if (!hasValidTags) {
      // No filter - clear filter
      onApply(null);
      onClose();
      return;
    }

    // Build expression from filter state
    const expression = buildExpressionFromGroups(filterState);
    onApply(expression);
    onClose();
  }, [filterState, onApply, onClose]);

  // ============================================================================
  // KEYBOARD HANDLERS
  // ============================================================================

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!isOpen) return;

      if (e.key === 'Escape') {
        onClose();
      } else if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
        handleApply();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, onClose, handleApply]);

  // Auto-focus search input when modal opens
  useEffect(() => {
    if (isOpen && searchInputRef.current) {
      searchInputRef.current.focus();
    }
  }, [isOpen]);

  // ============================================================================
  // FILTER GROUP HANDLERS
  // ============================================================================

  const handleAddGroup = () => {
    setFilterState(prev => ({
      ...prev,
      groups: [
        ...prev.groups,
        {
          id: crypto.randomUUID(),
          conditions: [{ id: crypto.randomUUID(), tagId: null }],
          internalLogic: 'AND',
          negated: false,
        },
      ],
    }));
  };

  const handleRemoveGroup = (groupId: string) => {
    setFilterState(prev => ({
      ...prev,
      groups: prev.groups.filter(g => g.id !== groupId),
    }));
  };

  const handleAddCondition = (groupId: string) => {
    setFilterState(prev => ({
      ...prev,
      groups: prev.groups.map(g =>
        g.id === groupId
          ? {
              ...g,
              conditions: [...g.conditions, { id: crypto.randomUUID(), tagId: null }],
            }
          : g
      ),
    }));
  };

  const handleRemoveCondition = (groupId: string, conditionId: string) => {
    setFilterState(prev => ({
      ...prev,
      groups: prev.groups.map(g =>
        g.id === groupId
          ? {
              ...g,
              conditions: g.conditions.filter(c => c.id !== conditionId),
            }
          : g
      ),
    }));
  };

  const handleConditionTagChange = (groupId: string, conditionId: string, tagId: number | null) => {
    setFilterState(prev => ({
      ...prev,
      groups: prev.groups.map(g =>
        g.id === groupId
          ? {
              ...g,
              conditions: g.conditions.map(c =>
                c.id === conditionId ? { ...c, tagId } : c
              ),
            }
          : g
      ),
    }));
  };

  const handleGroupLogicChange = (groupId: string, logic: FilterLogic) => {
    setFilterState(prev => ({
      ...prev,
      groups: prev.groups.map(g =>
        g.id === groupId ? { ...g, internalLogic: logic } : g
      ),
    }));
  };

  const handleGroupNegatedChange = (groupId: string, negated: boolean) => {
    setFilterState(prev => ({
      ...prev,
      groups: prev.groups.map(g =>
        g.id === groupId ? { ...g, negated } : g
      ),
    }));
  };

  const handleGroupLogicConnectorChange = (logic: FilterLogic) => {
    setFilterState(prev => ({ ...prev, groupLogic: logic }));
  };

  const handleClearAll = () => {
    setFilterState({
      groups: [{
        id: crypto.randomUUID(),
        conditions: [{ id: crypto.randomUUID(), tagId: null }],
        internalLogic: 'AND',
        negated: false,
      }],
      groupLogic: 'AND',
    });
  };

  const handleCancel = () => {
    onClose();
  };

  // ============================================================================
  // FILTERING
  // ============================================================================

  const filteredTags = allTags.filter(tag => {
    if (!searchQuery) return true;
    return tag.name.toLowerCase().includes(searchQuery.toLowerCase());
  });

  // Get all selected tag IDs across all groups
  const selectedTagIds = filterState.groups.flatMap(g =>
    g.conditions.map(c => c.tagId).filter((id): id is number => id !== null)
  );
  const selectedTags = allTags.filter(tag => selectedTagIds.includes(tag.id));

  // ============================================================================
  // RENDER
  // ============================================================================

  if (!isOpen) return null;

  return createPortal(
    <div className="modal-backdrop-premium" onClick={handleCancel}>
      <FocusTrap>
        <ErrorBoundary
          fallback={
            <div className="modal-panel-premium modal-md">
              <div className="p-8 text-center">
                <p className="text-slate-400">Tag Filter Modal encountered an error</p>
                <button onClick={handleCancel} className="btn btn-secondary mt-4">
                  Close
                </button>
              </div>
            </div>
          }
          onReset={handleCancel}
        >
          <div
            role="dialog"
            aria-modal="true"
            aria-labelledby="tag-filter-modal-title"
            className="modal-panel-premium modal-lg"
            onClick={(e) => e.stopPropagation()}
          >
            {/* Header */}
            <div className="flex items-center justify-between p-6 border-b border-surface-700">
              <h2
                id="tag-filter-modal-title"
                className="text-xl font-semibold text-slate-100"
              >
                Filter by Tags
              </h2>
              <button
                onClick={handleCancel}
                className="text-surface-400 hover:text-surface-200 transition-colors p-1 rounded hover:bg-surface-700"
                aria-label="Close modal"
              >
                <X className="w-5 h-5" />
              </button>
            </div>

            {/* Body */}
            <div className="p-6 space-y-6 max-h-[600px] overflow-y-auto">
              {/* Search Input */}
              <div className="relative">
                <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-surface-400" />
                <input
                  ref={searchInputRef}
                  type="text"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  placeholder="Search tags..."
                  aria-label="Search tags"
                  className="w-full pl-10 pr-4 py-2 bg-surface-700 border border-surface-600 rounded focus:outline-none focus:ring-2 focus:ring-primary-500/50 focus:border-primary-500 text-surface-100 placeholder-surface-400 transition-colors"
                />
              </div>

              {/* Visual Query Builder */}
              <div>
                <div className="flex items-center justify-between mb-3">
                  <h3 className="text-sm font-medium text-surface-300">Query Builder:</h3>
                  <button
                    onClick={handleClearAll}
                    className="text-xs text-surface-400 hover:text-surface-200 transition-colors"
                    aria-label="Clear all filters"
                  >
                    Clear All
                  </button>
                </div>

                <div className="space-y-3">
                  {filterState.groups.map((group, groupIndex) => (
                    <React.Fragment key={group.id}>
                      {/* Filter Group */}
                      <div className="bg-surface-800/50 border border-surface-700 rounded-lg p-4">
                        {/* Group Header */}
                        <div className="flex items-center justify-between mb-3">
                          <label className="flex items-center gap-2 cursor-pointer">
                            <input
                              type="checkbox"
                              checked={group.negated}
                              onChange={(e) => handleGroupNegatedChange(group.id, e.target.checked)}
                              className="w-4 h-4 bg-surface-700 border border-surface-600 rounded cursor-pointer focus:outline-none focus:ring-2 focus:ring-primary-500/50"
                              aria-label="Negate this group"
                            />
                            <span className="text-xs text-surface-400">NOT</span>
                          </label>
                          {filterState.groups.length > 1 && (
                            <button
                              onClick={() => handleRemoveGroup(group.id)}
                              className="text-xs text-surface-400 hover:text-red-400 transition-colors"
                              aria-label="Delete group"
                            >
                              Delete Group
                            </button>
                          )}
                        </div>

                        {/* Group Conditions */}
                        <div className="space-y-2">
                          {group.conditions.map((condition, conditionIndex) => (
                            <div key={condition.id} className="flex items-center gap-2">
                              {/* Tag Dropdown */}
                              <div className="relative flex-1">
                                <select
                                  value={condition.tagId ?? ''}
                                  onChange={(e) =>
                                    handleConditionTagChange(
                                      group.id,
                                      condition.id,
                                      e.target.value ? parseInt(e.target.value, 10) : null
                                    )
                                  }
                                  className="w-full appearance-none bg-surface-700 border border-surface-600 rounded px-3 py-2 pr-8 text-sm text-surface-200 cursor-pointer hover:bg-surface-600 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500/50"
                                  aria-label="Select tag"
                                >
                                  <option value="">Select tag...</option>
                                  {allTags.map(tag => (
                                    <option key={tag.id} value={tag.id}>
                                      #{tag.name} ({tag.usageCount})
                                    </option>
                                  ))}
                                </select>
                                <ChevronDown className="absolute right-2 top-1/2 -translate-y-1/2 w-4 h-4 text-surface-400 pointer-events-none" />
                              </div>

                              {/* Logic Operator (between conditions) */}
                              {conditionIndex < group.conditions.length - 1 && (
                                <div className="relative">
                                  <select
                                    value={group.internalLogic}
                                    onChange={(e) =>
                                      handleGroupLogicChange(group.id, e.target.value as FilterLogic)
                                    }
                                    className="appearance-none bg-surface-700 border border-surface-600 rounded px-2 py-2 pr-6 text-xs text-surface-300 cursor-pointer hover:bg-surface-600 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500/50"
                                    aria-label="Logic operator"
                                  >
                                    <option value="AND">AND</option>
                                    <option value="OR">OR</option>
                                  </select>
                                  <ChevronDown className="absolute right-1 top-1/2 -translate-y-1/2 w-3 h-3 text-surface-400 pointer-events-none" />
                                </div>
                              )}

                              {/* Remove Condition Button */}
                              {group.conditions.length > 1 && (
                                <button
                                  onClick={() => handleRemoveCondition(group.id, condition.id)}
                                  className="p-2 text-surface-400 hover:text-red-400 transition-colors"
                                  aria-label="Remove condition"
                                >
                                  <X className="w-4 h-4" />
                                </button>
                              )}
                            </div>
                          ))}
                        </div>

                        {/* Add Condition Button */}
                        <button
                          onClick={() => handleAddCondition(group.id)}
                          className="mt-3 text-xs text-surface-400 hover:text-surface-200 transition-colors"
                        >
                          + Add Condition
                        </button>
                      </div>

                      {/* Group Connector */}
                      {groupIndex < filterState.groups.length - 1 && (
                        <div className="flex justify-center">
                          <div className="relative">
                            <select
                              value={filterState.groupLogic}
                              onChange={(e) => handleGroupLogicConnectorChange(e.target.value as FilterLogic)}
                              className="appearance-none bg-surface-700 border border-surface-600 rounded px-3 py-1.5 pr-8 text-xs text-surface-300 cursor-pointer hover:bg-surface-600 transition-colors focus:outline-none focus:ring-2 focus:ring-primary-500/50"
                              aria-label="Group logic connector"
                            >
                              <option value="AND">AND</option>
                              <option value="OR">OR</option>
                            </select>
                            <ChevronDown className="absolute right-2 top-1/2 -translate-y-1/2 w-3 h-3 text-surface-400 pointer-events-none" />
                          </div>
                        </div>
                      )}
                    </React.Fragment>
                  ))}
                </div>

                {/* Add Group Button */}
                <button
                  onClick={handleAddGroup}
                  className="mt-4 text-sm text-surface-400 hover:text-surface-200 transition-colors"
                >
                  + Add Group
                </button>
              </div>

              {/* Expression Preview */}
              <div>
                <h3 className="text-sm font-medium text-surface-300 mb-2">Expression Preview:</h3>
                <div className="bg-surface-800 border border-surface-700 rounded px-3 py-2 font-mono text-xs text-surface-400">
                  {buildExpressionPreview(filterState, allTags) || '(no filter)'}
                </div>
              </div>
            </div>

            {/* Footer */}
            <div className="flex items-center justify-end gap-3 p-6 border-t border-surface-700">
              <button
                onClick={handleCancel}
                className="btn btn-secondary min-w-[100px]"
              >
                Cancel
              </button>
              <button
                onClick={handleApply}
                className="btn btn-primary min-w-[100px]"
              >
                Apply Filter
              </button>
            </div>
          </div>
        </ErrorBoundary>
      </FocusTrap>
    </div>,
    document.body
  );
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Build a TagFilterExpression from FilterState
 */
function buildExpressionFromGroups(state: FilterState): TagFilterExpression {
  // Filter out groups with no valid tags
  const validGroups = state.groups.filter(g =>
    g.conditions.some(c => c.tagId !== null)
  );

  if (validGroups.length === 0) {
    throw new Error('Cannot build expression with no tags');
  }

  // Build expressions for each group
  const groupExpressions = validGroups.map(group => {
    const validConditions = group.conditions.filter(c => c.tagId !== null);
    
    let groupExpr: TagFilterExpression;
    
    if (validConditions.length === 1) {
      groupExpr = {
        type: 'tag',
        tagId: validConditions[0].tagId!,
      };
    } else {
      groupExpr = {
        type: group.internalLogic.toLowerCase() as 'and' | 'or',
        children: validConditions.map(c => ({
          type: 'tag',
          tagId: c.tagId!,
        })),
      };
    }

    // Apply negation if needed
    if (group.negated) {
      return {
        type: 'not',
        children: [groupExpr],
      };
    }

    return groupExpr;
  });

  // Combine groups with group logic
  if (groupExpressions.length === 1) {
    return groupExpressions[0];
  }

  return {
    type: state.groupLogic.toLowerCase() as 'and' | 'or',
    children: groupExpressions,
  };
}

/**
 * Parse a TagFilterExpression into FilterState
 */
function parseExpressionToGroups(expression: TagFilterExpression): FilterState {
  // Simple implementation: if it's a flat AND/OR, create a single group
  // If it's complex, try to parse into multiple groups
  
  const groups: FilterGroup[] = [];
  let groupLogic: FilterLogic = 'AND';

  // Check if top-level is AND/OR with multiple children
  if ((expression.type === 'and' || expression.type === 'or') && expression.children) {
    groupLogic = expression.type.toUpperCase() as FilterLogic;
    
    // Try to parse each child as a group
    for (const child of expression.children) {
      const group = parseExpressionToGroup(child);
      if (group) {
        groups.push(group);
      }
    }
  } else {
    // Single expression, create one group
    const group = parseExpressionToGroup(expression);
    if (group) {
      groups.push(group);
    }
  }

  // Fallback to default if no groups parsed
  if (groups.length === 0) {
    groups.push({
      id: crypto.randomUUID(),
      conditions: [{ id: crypto.randomUUID(), tagId: null }],
      internalLogic: 'AND',
      negated: false,
    });
  }

  return { groups, groupLogic };
}

/**
 * Parse a single expression into a FilterGroup
 */
function parseExpressionToGroup(expression: TagFilterExpression): FilterGroup | null {
  let negated = false;
  let expr = expression;

  // Check for NOT wrapper
  if (expr.type === 'not' && expr.children && expr.children[0]) {
    negated = true;
    expr = expr.children[0];
  }

  // Single tag
  if (expr.type === 'tag' && expr.tagId !== undefined) {
    return {
      id: crypto.randomUUID(),
      conditions: [{ id: crypto.randomUUID(), tagId: expr.tagId }],
      internalLogic: 'AND',
      negated,
    };
  }

  // AND/OR with children
  if ((expr.type === 'and' || expr.type === 'or') && expr.children) {
    const conditions: FilterCondition[] = [];
    
    for (const child of expr.children) {
      if (child.type === 'tag' && child.tagId !== undefined) {
        conditions.push({ id: crypto.randomUUID(), tagId: child.tagId });
      }
    }

    if (conditions.length > 0) {
      return {
        id: crypto.randomUUID(),
        conditions,
        internalLogic: expr.type.toUpperCase() as FilterLogic,
        negated,
      };
    }
  }

  return null;
}

/**
 * Build human-readable expression preview from FilterState
 */
function buildExpressionPreview(state: FilterState, tags: Tag[]): string {
  const validGroups = state.groups.filter(g =>
    g.conditions.some(c => c.tagId !== null)
  );

  if (validGroups.length === 0) {
    return '';
  }

  const groupStrings = validGroups.map(group => {
    const validConditions = group.conditions.filter(c => c.tagId !== null);
    const tagNames = validConditions
      .map(c => tags.find(t => t.id === c.tagId))
      .filter((tag): tag is Tag => tag !== undefined)
      .map(tag => `#${tag.name}`);

    if (tagNames.length === 0) {
      return '';
    }

    let groupStr = tagNames.length === 1
      ? tagNames[0]
      : `(${tagNames.join(` ${group.internalLogic} `)})`;

    if (group.negated) {
      groupStr = `NOT ${groupStr}`;
    }

    return groupStr;
  }).filter(s => s);

  if (groupStrings.length === 0) {
    return '';
  }

  if (groupStrings.length === 1) {
    return groupStrings[0];
  }

  return groupStrings.join(` ${state.groupLogic} `);
}
